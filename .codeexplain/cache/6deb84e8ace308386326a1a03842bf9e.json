{"fileHash":"67a301cfbce6d814dfa5998f96139da7dccab53088aeef8191edb5e8093a2624","mtime":1758618787117,"explanation":"This PHP file, `ProjectPlannerAgent.php`, acts as a specialized **AI agent** designed to help plan software projects. Think of it as a smart assistant that can generate various project documents like requirements, design, and development plans using different Artificial Intelligence models.\n\nLet's break down the code piece by piece:\n\n---\n\n### 1. File Header and Namespace\n\n```php\n<?php\n\nnamespace ProjectPlanner;\n```\n\n*   `<?php`: This is the standard opening tag for PHP code.\n*   `namespace ProjectPlanner;`: This line defines the \"address\" for this file. It means this `ProjectPlannerAgent` class belongs to the `ProjectPlanner` family of code. Namespaces help organize code, especially in larger projects, preventing name conflicts between classes with the same name.\n\n---\n\n### 2. Importing Other Classes (`use` statements)\n\n```php\nuse NeuronAI\\Agent;\nuse NeuronAI\\Chat\\Messages\\UserMessage;\nuse NeuronAI\\Providers\\AIProviderInterface;\nuse NeuronAI\\Providers\\Anthropic\\Anthropic;\nuse NeuronAI\\Providers\\Gemini\\Gemini;\nuse NeuronAI\\Providers\\Ollama\\Ollama;\nuse NeuronAI\\Providers\\OpenAI\\OpenAI;\n```\n\nThese lines are like saying, \"Hey, I'm going to use some tools from other toolboxes in this file.\"\n*   `use NeuronAI\\Agent;`: This class is the base for our `ProjectPlannerAgent`. It provides core functionalities for interacting with AI.\n*   `use NeuronAI\\Chat\\Messages\\UserMessage;`: This is used to create a message that we send *to* the AI, acting as if a user typed it.\n*   `use NeuronAI\\Providers\\AIProviderInterface;`: This is a \"contract\" or a blueprint that all AI providers (like Anthropic, Gemini, etc.) must follow, ensuring they all have similar ways of being used.\n*   `use NeuronAI\\Providers\\Anthropic\\Anthropic;`, `Gemini\\Gemini;`, `Ollama\\Ollama;`, `OpenAI\\OpenAI;`: These are specific classes for connecting to different AI services like Anthropic's Claude, Google's Gemini, the local Ollama, and OpenAI's ChatGPT models.\n\n---\n\n### 3. Class Definition\n\n```php\nclass ProjectPlannerAgent extends Agent\n{\n    // ... code inside the class ...\n}\n```\n\n*   `class ProjectPlannerAgent`: This declares our main class, `ProjectPlannerAgent`. This is where all the related code for our project planning AI assistant will live.\n*   `extends Agent`: This is a very important part! It means our `ProjectPlannerAgent` *inherits* all the properties and methods (variables and functions) from the `Agent` class (from `NeuronAI`). So, our `ProjectPlannerAgent` automatically gets capabilities like sending messages to an AI without us having to write that code again. This is called **inheritance** and is a core concept in Object-Oriented Programming (OOP).\n\n---\n\n### 4. Class Constants (Timeouts)\n\n```php\n    private const AI_TIMEOUT_MS = 300000; // 5 minutes for AI operations\n    private const API_TIMEOUT_SECONDS = 300; // 5 minutes for API operations\n```\n\n*   `private const`: These are special variables whose values **cannot be changed** once set. They are also `private`, meaning they can only be used *inside* this `ProjectPlannerAgent` class.\n*   `AI_TIMEOUT_MS` and `API_TIMEOUT_SECONDS`: These define how long the system should wait for an AI or API operation to complete before giving up (5 minutes in both cases, measured in milliseconds and seconds respectively). This prevents the program from waiting forever if an AI service is slow or unresponsive.\n\n---\n\n### 5. Class Properties\n\n```php\n    private DiagramGenerator $diagramGenerator;\n    private PromptService $promptService;\n```\n\nThese are variables that belong to our `ProjectPlannerAgent` class. They store other objects that our agent needs to do its job.\n*   `private`: Only accessible from inside this class.\n*   `DiagramGenerator $diagramGenerator;`: This variable will hold an object that knows how to create diagrams. The `$diagramGenerator` part is the variable name, and `DiagramGenerator` before it tells us what *type* of object it's expected to hold.\n*   `PromptService $promptService;`: This variable will hold an object that knows how to build the right questions (prompts) to send to the AI.\n\n---\n\n### 6. Constructor Method\n\n```php\n    public function __construct()\n    {\n        $this->diagramGenerator = new DiagramGenerator();\n        $this->promptService = new PromptService();\n    }\n```\n\n*   `public function __construct()`: This is a special method called a **constructor**. It runs automatically whenever you create a new `ProjectPlannerAgent` object (e.g., `$agent = new ProjectPlannerAgent();`).\n*   `$this->diagramGenerator = new DiagramGenerator();`: Inside the constructor, we create a new `DiagramGenerator` object and store it in our `$diagramGenerator` property. The `$`this` keyword refers to the current `ProjectPlannerAgent` object.\n*   `$this->promptService = new PromptService();`: Similarly, we create a new `PromptService` object.\n    *   **In simple terms**: When you \"make\" a `ProjectPlannerAgent`, it immediately gets its own `DiagramGenerator` and `PromptService` ready to use.\n\n---\n\n### 7. Helper Method: `callAIAndExtractContent()`\n\n```php\n    /**\n     * Call AI with prompt and extract markdown content from response\n     */\n    private function callAIAndExtractContent(string $prompt): string\n    {\n        $response = $this->chat(new UserMessage($prompt));\n        $content = $response->getContent();\n        return $this->extractMarkdownContent($content);\n    }\n```\n\n*   `private function`: This is a helper function, meaning it's used internally by this class and not directly called from outside.\n*   `string $prompt`: It takes one input: a `$prompt` (the question for the AI), which must be a `string` (text).\n*   `: string`: It is expected to return a `string`.\n*   `$response = $this->chat(new UserMessage($prompt));`: This is the core interaction. It calls the `chat()` method (which is inherited from the `Agent` class) and sends it a `UserMessage` containing our `$prompt`. The `chat()` method then sends this to the actual AI service and gets a `$response`.\n*   `$content = $response->getContent();`: We then get the actual text of the AI's answer from the `$response` object.\n*   `return $this->extractMarkdownContent($content);`: Finally, it takes the AI's raw answer and passes it to another method (`extractMarkdownContent`) to clean it up and return just the important Markdown text.\n\n---\n\n### 8. Provider Method: `provider()`\n\n```php\n    protected function provider(): AIProviderInterface\n    {\n        // ... code to select AI provider ...\n    }\n```\n\n*   `protected function provider()`: This method is `protected`, meaning it can be accessed within this class and by any classes that inherit from `ProjectPlannerAgent`. It's responsible for setting up which specific AI model (like Anthropic, Gemini, OpenAI, or Ollama) our agent will use.\n*   `: AIProviderInterface`: It must return an object that adheres to the `AIProviderInterface` blueprint.\n*   `config('ai.provider', 'gemini');`: This line retrieves settings from a configuration file (like a settings file for your application). It looks for an entry named `'ai.provider'` and, if it doesn't find one, defaults to `'gemini'`. The same happens for `model`, `apiKey`, `temperature`, and `maxTokens`.\n*   `date('Y-m-d');`: This gets today's date, which might be included in some prompts later.\n*   **`switch ($provider)`**: This block checks the value of `$provider` (e.g., 'anthropic', 'ollama', 'openai', 'gemini') and creates the appropriate AI service object.\n    *   **Anthropic, Ollama, OpenAI**: Each case creates a new object for that specific AI service, passing in the `key` (API key for authentication), `model` (e.g., 'claude-3-5-sonnet-20240620', 'llama3', 'gpt-4o'), and other `parameters` like `temperature` (how creative/random the AI's response is) and `max_tokens` (the maximum length of the AI's response).\n    *   **Gemini (and `default`)**: This is the default choice. It also includes `safetySettings` to control how strictly the AI filters out potentially harmful content.\n*   **In simple terms**: This method acts like a switchboard. Based on your application's settings, it connects your agent to a specific AI brain (like Gemini, OpenAI, etc.) and configures it with the right model and behavior.\n\n---\n\n### 9. Public Functionality Methods\n\nThese methods are the main ways you would interact with the `ProjectPlannerAgent` from outside the class to generate different project documents.\n\n*   `public function generatePRD(string $projectName, string $projectIdea): string`\n    *   **PRD** stands for **Product Requirements Document**.\n    *   It takes a `$projectName` and a `$projectIdea` as input.\n    *   It uses `$this->promptService->buildPRDPrompt()` to create a detailed question for the AI based on the project details.\n    *   Then it calls `$this->callAIAndExtractContent()` to send the prompt to the AI, get the response, and clean it up.\n    *   It returns the generated PRD content as a string.\n\n*   `public function generateSDD(string $projectName, string $prdContent): string`\n    *   **SDD** stands for **System Design Document**.\n    *   It takes the `$projectName` and the previously generated `$prdContent` (the requirements).\n    *   It uses these to build a prompt for the AI to generate a system design.\n    *   It returns the generated SDD content.\n\n*   `public function generateDiagram(string $projectName, string $projectIdea): ?string`\n    *   This method generates a visual diagram.\n    *   It builds a prompt to ask the AI for diagram code (specifically \"DOT code,\" a language for describing graphs).\n    *   `$response = $this->chat(new UserMessage($prompt));`: It sends this prompt to the AI.\n    *   `$dotCode = $this->diagramGenerator->extractDotCode($content);`: It takes the AI's raw answer and uses the `DiagramGenerator` to find and extract the special DOT code.\n    *   `return $this->diagramGenerator->generatePngFromDot($dotCode);`: Finally, it tells the `DiagramGenerator` to convert that DOT code into an actual image (PNG format) and returns its path or content. The `?string` return type means it might return a string or `null` (if something goes wrong).\n\n*   `public function generatePlan(string $projectName, string $sddContent): string`\n    *   This generates a **Development Plan**, using the `$projectName` and the `$sddContent` (system design) as input to guide the AI.\n\n*   `public function generatePhases(string $planContent): string`\n    *   This generates project **Phases** (breaking the plan into smaller steps), based on the `$planContent`.\n\n*   `public function generateAIInstructions(string $projectName): string`\n    *   This is a bit different. Notice it **doesn't call the AI** (`$this->callAIAndExtractContent()`).\n    *   Instead, it directly calls `$this->buildAIInstructionsContent()` to create a standard set of instructions for other AI agents working on the project. This means these instructions are static and don't change based on AI's creativity.\n\n---\n\n### 10. Private Helper Method: `buildAIInstructionsContent()`\n\n```php\n    private function buildAIInstructionsContent(string $projectName): string\n    {\n        return \"# AI Coding Agent Instructions for {$projectName}\\n\\n// ... more markdown content ...\";\n    }\n```\n\n*   `private function`: This is a helper function used only within this class.\n*   It takes `$projectName` as input.\n*   It returns a long string containing pre-defined Markdown text. This text is an instruction guide for other AI agents, explaining the project structure and the purpose of different project documents (PRD, SDD, plan, phases, etc.).\n*   `{$projectName}`: This is an example of embedding a variable's value directly into a string.\n\n---\n\n### 11. Protected Helper Method: `extractMarkdownContent()`\n\n```php\n    /**\n     * Extract clean markdown content from AI response\n     * Removes explanatory text before/after markdown code blocks\n     */\n    protected function extractMarkdownContent(string $content): string\n    {\n        // ... logic to extract markdown ...\n    }\n```\n\n*   `protected function`: This method is `protected` because it's a utility for this class and potentially for any future classes that inherit from it.\n*   Its purpose is to clean up the raw text response received from the AI. AI models sometimes add conversational text around the actual Markdown content you want (e.g., \"Here is your PRD document: \\`\\`\\`markdown # My Project ... \\`\\`\\`\"). This method tries to strip that away.\n*   `$pattern = '/```(?:markdown)?\\s*(.*?)\\s*```/s';`: This is a **regular expression** (regex). It's a powerful pattern-matching language. This specific pattern tries to find blocks of text enclosed within triple backticks (````` ``` ``, often used for code blocks in Markdown), optionally followed by `markdown`.\n    *   If it finds such a block, it extracts the content inside (`$matches[1]`) and `trim()`s (removes whitespace from ends) it.\n    *   `preg_match()`: This PHP function tries to match a regular expression pattern against a string.\n*   `if (preg_match('/^#{1,6} /m', $extracted))`: After finding a code block, it checks if the extracted content actually looks like a proper Markdown document by checking for Markdown headers (`#`, `##`, etc.).\n*   If no code blocks are found, or the code block doesn't seem to contain a full document, it then tries to find the *first Markdown header* in the entire response and returns everything from that header onwards.\n*   If all else fails, it just returns the entire content after trimming whitespace.\n*   **In simple terms**: This function is a smart cleaner. It looks for the actual Markdown document hidden within the AI's chatty response and gives you just that document.\n\n---\n\n### Summary\n\nThis `ProjectPlannerAgent` class is a sophisticated AI assistant for project management. It can:\n1.  **Connect to various AI providers** (Gemini, OpenAI, Anthropic, Ollama) based on configuration.\n2.  **Generate key project documents** like Product Requirements (PRD), System Design (SDD), Development Plans, and Project Phases by crafting specific prompts and interpreting AI responses.\n3.  **Generate visual diagrams** from AI-provided descriptions.\n4.  **Provide static instructions** for other AI agents or developers.\n5.  **Clean and format AI responses** to extract usable Markdown content.\n\nIt uses an object-oriented approach by inheriting from a base `Agent` class and composing other helper services (`DiagramGenerator`, `PromptService`) to keep its code organized and efficient.","timestamp":"2025-09-23T14:11:55.949Z","config":{"mode":"explain","level":"beginner","provider":"gemini","model":"gemini-2.5-flash"}}
