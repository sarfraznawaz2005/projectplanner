{"fileHash":"c1958540fcf100a4120677102ecb2c7c6a7b580218fe79c00e7e91725f44a427","mtime":1758618301738,"explanation":"This PHP file, `FileService.php`, is like a toolbox specifically designed to help your `ProjectPlanner` application manage files and directories related to different projects. Think of it as a dedicated helper that knows how to create project folders, save documents, package everything into a ZIP file, and clean up afterwards.\n\nLet's break down each part of the code:\n\n---\n\n### File Location and Name\n\n*   **File:** `D:\\laragon\\www\\ProjectPlanner\\src\\FileService.php`\n*   **Purpose:** This tells us it's part of a project called `ProjectPlanner`, located in the `src` (source) directory, and its job is to handle \"File Services.\"\n\n---\n\n### 1. `<?php`\n\nThis is the standard opening tag for a PHP script, indicating that the code following it is PHP.\n\n---\n\n### 2. `namespace ProjectPlanner;`\n\n*   **Concept:** Namespaces help organize your code, especially in larger applications, to prevent naming conflicts.\n*   **Explanation:** This line declares that the `FileService` class belongs to the `ProjectPlanner` namespace. If you have another `FileService` class in a different part of your application (e.g., `App\\Utility\\FileService`), PHP knows they are distinct because they are in different namespaces.\n\n---\n\n### 3. `class FileService`\n\n*   **Concept:** A class is a blueprint for creating objects. An object is an instance of a class.\n*   **Explanation:** This defines a class named `FileService`. All the functions (methods) and data (properties) related to file operations for projects will be bundled inside this class.\n\n---\n\n### 4. `private string $projectsDir;`\n\n*   **Concept:**\n    *   **Property (or Member Variable):** A variable declared inside a class.\n    *   **`private`:** An \"access modifier\" that means this property can *only* be accessed from *inside* this `FileService` class itself. Other parts of your application cannot directly read or change `$projectsDir`. This helps protect the data.\n    *   **`string`:** A \"type hint\" that tells us this variable is expected to hold a text string (like `\"C:\\my-projects\"`).\n*   **Explanation:** This line declares a private property named `$projectsDir`. Its purpose is to store the base directory where all project folders will be created.\n\n---\n\n### 5. `public function __construct()`\n\n*   **Concept:**\n    *   **`public`:** Another access modifier, meaning this method can be called from anywhere, even outside the `FileService` class.\n    *   **`__construct()`:** This is a special method in PHP called a \"constructor.\" It's automatically run whenever you create a new \"instance\" (object) of the `FileService` class.\n*   **Explanation:** When you create a new `FileService` object, this constructor immediately gets called. Its job is to set up the `$projectsDir` property.\n    *   `$this->projectsDir = config('paths.projects');`\n        *   `$this` refers to the *current* object of the `FileService` class.\n        *   `config('paths.projects')` is likely a helper function (common in frameworks like Laravel or custom setups) that reads a configuration value. It probably fetches the path to where all project folders should be stored from your application's settings (e.g., `D:\\laragon\\www\\ProjectPlanner\\projects`).\n        *   So, this line sets the `$projectsDir` property of the `FileService` object to the path specified in your application's configuration.\n\n---\n\n### 6. `public function createProjectDirectory(string $projectName): string`\n\n*   **Concept:**\n    *   **`public`:** This method can be called from outside the class.\n    *   **`string $projectName`:** This method expects one input, a `string` (text) representing the project's name.\n    *   **`: string`:** This is a \"return type declaration,\" meaning this method is guaranteed to return a `string` (in this case, the full path to the created project directory).\n*   **Explanation:** This method's job is to create a new folder for a project.\n    *   `$safeName = $this->sanitizeFilename($projectName);`\n        *   It first calls another *private* method within this class, `sanitizeFilename()`, to clean up the `$projectName`. This is important to remove any characters that might cause problems in a file path (like `?`, `/`, `*`, etc.).\n    *   `$projectDir = $this->projectsDir . '/' . $safeName;`\n        *   It then combines the base project directory (from `$projectsDir`) with the cleaned project name to form the full path for the new project folder.\n    *   `if (!is_dir($projectDir)) { ... }`\n        *   `is_dir()` is a built-in PHP function that checks if a given path exists and is a directory.\n        *   The `!` means \"NOT\". So, `!is_dir($projectDir)` checks \"if the project directory does NOT already exist.\"\n    *   `mkdir($projectDir, 0755, true);`\n        *   If the directory doesn't exist, `mkdir()` (Make Directory) is called to create it.\n        *   `0755`: These are file permissions. It's a common setting meaning:\n            *   `7` (owner) can read, write, and execute.\n            *   `5` (group) can read and execute.\n            *   `5` (others) can read and execute.\n        *   `true`: This is the `recursive` parameter. It means if the parent directories (e.g., `D:\\laragon\\www\\ProjectPlanner\\projects`) don't exist, `mkdir` will create them too.\n    *   `return $projectDir;`\n        *   Finally, it returns the full path to the newly created (or existing) project directory.\n\n---\n\n### 7. `public function saveProjectDocuments(string $projectDir, array $documents): void`\n\n*   **Concept:**\n    *   **`array $documents`:** This method expects a `string` for the project directory and an `array` (a list of items) for the documents.\n    *   **`: void`:** This \"return type declaration\" means this method does *not* return any value. Its job is just to perform an action (saving files).\n*   **Explanation:** This method takes the path to a project directory and an array of document content, then saves these documents as files within that directory.\n    *   `$fileMappings = [...]`\n        *   This creates an array that maps internal keys (like `'prd'`, `'sdd'`) to their desired filenames (like `'prd.md'`, `'sdd.md'`). `.md` usually means a Markdown file.\n    *   `foreach ($fileMappings as $key => $filename) { ... }`\n        *   This loop goes through each item in the `$fileMappings` array.\n        *   `$key` will be `prd`, `sdd`, etc.\n        *   `$filename` will be `prd.md`, `sdd.md`, etc.\n    *   `if (!empty($documents[$key])) { ... }`\n        *   `!empty()` checks if the `$documents` array has an entry for the current `$key` (e.g., `documents['prd']`) AND if that entry is not empty. This ensures we only try to save content that actually exists.\n    *   `file_put_contents($projectDir . '/' . $filename, $documents[$key]);`\n        *   `file_put_contents()` is a convenient PHP function that writes a string to a file. If the file doesn't exist, it creates it. If it does, it overwrites it.\n        *   It constructs the full file path (e.g., `[projectDir]/prd.md`) and writes the content from `$documents[$key]` into it.\n\n    *   **Handling Diagram (Special Case):**\n        *   `if (!empty($documents['systemArchDiagram'])) { ... }`\n            *   Checks if there's a system architecture diagram.\n        *   `$diagramBinary = base64_decode($documents['systemArchDiagram']);`\n            *   Diagrams are often sent as \"Base64 encoded\" strings, which is a way to represent binary data (like images) as plain text. `base64_decode()` converts this text back into its original binary image data.\n        *   `if ($diagramBinary !== false) { ... }`\n            *   `base64_decode()` returns `false` if the input is not valid Base64. This checks if the decoding was successful.\n        *   `file_put_contents($projectDir . '/system_architecture.png', $diagramBinary);`\n            *   Saves the decoded binary image data as `system_architecture.png` in the project directory.\n\n    *   **Splitting Phases:**\n        *   `if (!empty($documents['phases'])) { ... }`\n            *   Checks if there's content for \"phases.\"\n        *   `$this->splitPhaseDocuments($projectDir, $documents['phases']);`\n            *   Calls another *private* method of this class to take the single \"phases\" document and split it into multiple files, one for each phase. This makes the project structure more organized.\n\n---\n\n### 8. `public function createProjectZip(string $projectDir, string $projectName): string`\n\n*   **Explanation:** This method creates a ZIP archive of all files within a given project directory.\n    *   `$safeName = $this->sanitizeFilename($projectName);`\n        *   Cleans up the project name to ensure the ZIP file name is valid.\n    *   `$zipFile = $projectDir . '.zip';`\n        *   Determines the name of the ZIP file (e.g., `my_project.zip`). It puts the zip file in the same directory as the project folder.\n    *   `$zip = new \\ZipArchive();`\n        *   `\\ZipArchive` is a built-in PHP class for working with ZIP archives. This line creates a new `ZipArchive` object. The `\\` before `ZipArchive` is important, it means \"use the global `ZipArchive` class,\" not one within our current `ProjectPlanner` namespace.\n    *   `if ($zip->open($zipFile, \\ZipArchive::CREATE | \\ZipArchive::OVERWRITE) !== true) { ... }`\n        *   `$zip->open()` attempts to open the specified ZIP file.\n        *   `\\ZipArchive::CREATE`: If the file doesn't exist, create it.\n        *   `\\ZipArchive::OVERWRITE`: If the file exists, overwrite it.\n        *   The `|` (bitwise OR) combines these flags.\n        *   If opening fails, it throws a `\\RuntimeException` (a type of error) with a message. This stops the script and indicates a problem.\n    *   `$files = new \\RecursiveIteratorIterator(...)`\n        *   This is a sophisticated way to list all files and directories *recursively* (meaning it goes into subfolders) within `$projectDir`.\n        *   `\\RecursiveDirectoryIterator($projectDir)`: Starts at the project directory and can iterate over its contents.\n        *   `\\RecursiveIteratorIterator(..., \\RecursiveIteratorIterator::LEAVES_ONLY)`: This wraps the directory iterator to ensure we only get individual files (\"leaves\") and not the directories themselves in our loop.\n    *   `foreach ($files as $name => $file) { ... }`\n        *   This loop goes through every file found by the iterator.\n    *   `if (!$file->isDir()) { ... }`\n        *   Ensures we only process actual files, not directories.\n    *   `$filePath = $file->getRealPath();`\n        *   Gets the full, absolute path to the current file (e.g., `D:\\laragon\\www\\ProjectPlanner\\projects\\my_project\\prd.md`).\n    *   `$relativePath = substr($filePath, strlen($projectDir) + 1);`\n        *   This calculates the path of the file *relative* to the project directory. For example, if `$filePath` is `.../my_project/prd.md` and `$projectDir` is `.../my_project`, `$relativePath` will be `prd.md`. This is how files are typically stored *inside* a ZIP file.\n    *   `$zip->addFile($filePath, $relativePath);`\n        *   Adds the file to the ZIP archive. The first argument is the actual file path on the disk, and the second is how it should appear inside the ZIP.\n    *   `$zip->close();`\n        *   Important! This saves and closes the ZIP archive.\n    *   `return $zipFile;`\n        *   Returns the full path to the created ZIP file.\n\n---\n\n### 9. `public function cleanupProjectFiles(string $projectDir, string $zipFile): void`\n\n*   **Explanation:** This method is responsible for deleting the project folder and the temporary ZIP file after they are no longer needed (e.g., after the ZIP has been downloaded by a user).\n    *   `$this->removeDirectory($projectDir);`\n        *   Calls another *private* method to recursively delete the entire project directory and all its contents.\n    *   `if (file_exists($zipFile)) { ... }`\n        *   Checks if the ZIP file still exists.\n    *   `unlink($zipFile);`\n        *   If the ZIP file exists, `unlink()` deletes it.\n\n---\n\n### 10. `private function sanitizeFilename(string $filename): string`\n\n*   **Concept:** This is a *private* helper method, meaning it can only be called by other methods within the `FileService` class. It's not meant to be called directly from outside.\n*   **Explanation:** This method takes a string (like a project name or a phase title) and makes it safe to use as part of a filename or directory name.\n    *   `$filename = preg_replace('/[^A-Za-z0-9\\-_\\.]/', '_', $filename);`\n        *   `preg_replace()` is a powerful PHP function that uses \"regular expressions\" to find and replace patterns in a string.\n        *   `/[^A-Za-z0-9\\-_\\.]/`: This is the pattern.\n            *   `[` and `]` define a character set.\n            *   `^` inside `[]` means \"NOT\" (negation).\n            *   `A-Za-z0-9`: Allows uppercase letters, lowercase letters, and numbers.\n            *   `\\-_\\.`: Allows hyphens, underscores, and periods.\n            *   So, this pattern matches *any character that is NOT* an English letter, number, hyphen, underscore, or period.\n        *   `'_'`: Any character that matches the pattern will be replaced with an underscore.\n        *   **Example:** `My Project Name!` becomes `My_Project_Name_`.\n    *   `$filename = preg_replace('/_+/', '_', $filename);`\n        *   `/_+/`: This pattern matches *one or more* consecutive underscores.\n        *   It replaces multiple underscores with a single underscore.\n        *   **Example:** `My__Project___Name` becomes `My_Project_Name`. This prevents messy filenames.\n    *   `return trim($filename, '_');`\n        *   `trim()` removes specified characters from the beginning and end of a string.\n        *   `trim($filename, '_')` removes any leading or trailing underscores.\n        *   **Example:** `_My_Project_` becomes `My_Project`.\n\n---\n\n### 11. `private function splitPhaseDocuments(string $projectDir, string $phasesContent): void`\n\n*   **Concept:** Another private helper method, used by `saveProjectDocuments`.\n*   **Explanation:** This method takes the full content of all phases (which might be a single Markdown string) and splits it into individual Markdown files, one for each phase.\n    *   `$phases = preg_split('/^## Phase \\d+/m', $phasesContent, -1, PREG_SPLIT_NO_EMPTY);`\n        *   `preg_split()` splits a string into an array of strings using a regular expression as a delimiter.\n        *   `/^## Phase \\d+/m`: This is the pattern for splitting.\n            *   `^`: Matches the beginning of a line.\n            *   `## Phase \\d+`: Matches the literal text \"## Phase \" followed by one or more digits (e.g., \"## Phase 1\", \"## Phase 2\").\n            *   `/m`: The `m` flag makes `^` match the beginning of *each line* (multiline mode), not just the beginning of the entire string.\n        *   `-1`: Splits into as many parts as necessary.\n        *   `PREG_SPLIT_NO_EMPTY`: Ensures that empty results from the split are not included in the final array.\n        *   **Result:** This will split the `$phasesContent` wherever it finds a line starting with \"## Phase N\".\n    *   `if (count($phases) > 1) { array_shift($phases); }`\n        *   Sometimes, if the content *starts* with something before the first `## Phase`, `preg_split` might create an empty or irrelevant first element. `array_shift()` removes the first element of an array.\n    *   `foreach ($phases as $index => $phaseContent) { ... }`\n        *   Loops through each separated phase's content.\n    *   `$phaseNumber = $index + 1;`\n        *   Calculates a human-readable phase number (starting from 1).\n    *   `$phaseTitle = \"Phase {$phaseNumber}\";`\n        *   Sets a default phase title.\n    *   `if (preg_match('/^## (.+)$/m', $phaseContent, $matches)) { ... }`\n        *   `preg_match()` attempts to find a pattern in a string.\n        *   `/^## (.+)$/m`: This pattern tries to extract the actual title if it's immediately after `##` on a new line.\n            *   `(.+)`: This is a \"capturing group\" that captures any characters after `## ` until the end of the line.\n        *   If a title is found, it's stored in `$matches[1]`.\n        *   `$phaseTitle = trim($matches[1]);` sets the phase title to the extracted one, removing extra spaces.\n    *   `$safeTitle = $this->sanitizeFilename($phaseTitle);`\n        *   Cleans up the extracted phase title to make it safe for a filename.\n    *   `$fileName = $projectDir . '/' . $safeTitle . '.md';`\n        *   Constructs the full path for the individual phase file.\n    *   `file_put_contents($fileName, \"## {$phaseTitle}\\n\\n\" . trim($phaseContent));`\n        *   Writes the content to the new file. It prepends `## {Phase Title}\\n\\n` to ensure the file starts with a proper Markdown heading, and `trim()` cleans up any extra whitespace from the content.\n\n---\n\n### 12. `private function removeDirectory(string $dir): void`\n\n*   **Concept:** A private recursive helper method to delete a directory and all its contents.\n*   **Explanation:** This is a crucial and powerful function that deletes an entire folder, including any subfolders and files inside it. It uses a technique called \"recursion\" (a function calling itself).\n    *   `if (!is_dir($dir)) { return; }`\n        *   First, it checks if the given path is actually a directory. If not, there's nothing to do, so it simply stops (`return;`).\n    *   `$files = array_diff(scandir($dir), ['.', '..']);`\n        *   `scandir($dir)` lists all files and directories inside `$dir`. This usually includes `.` (current directory) and `..` (parent directory).\n        *   `array_diff(..., ['.', '..'])` removes `.` and `..` from the list, as we don't want to try and delete them.\n    *   `foreach ($files as $file) { ... }`\n        *   It then loops through every item (file or sub-directory) found within the current directory.\n    *   `$path = $dir . '/' . $file;`\n        *   Constructs the full path to the current item.\n    *   `if (is_dir($path)) { $this->removeDirectory($path); }`\n        *   **This is the recursion part!** If the current item is a directory, it calls `removeDirectory()` *itself* with the path to that sub-directory. This means it will go into that sub-directory and start deleting its contents before returning to the current level.\n    *   `else { unlink($path); }`\n        *   If the current item is *not* a directory (meaning it's a file), `unlink($path)` deletes the file.\n    *   `rmdir($dir);`\n        *   **After** all files and sub-directories within the current `$dir` have been deleted (thanks to the loop and recursion), `rmdir($dir)` (Remove Directory) finally deletes the now-empty current directory itself.\n\n---\n\n### In Summary:\n\nThe `FileService` class provides a robust set of tools for managing project files:\n1.  **Setting up:** It knows where to put project files from your app's configuration.\n2.  **Creation:** It can create a dedicated, safely named directory for each project.\n3.  **Saving:** It can save various documents (Markdown, diagrams) into the project directory, including decoding images and splitting multi-phase content.\n4.  **Packaging:** It can compress all project files into a single ZIP archive.\n5.  **Cleanup:** It can safely delete project directories and temporary ZIP files when they are no longer needed.\n6.  **Safety:** It includes private helper methods for sanitizing filenames and recursively deleting directories to prevent errors and ensure proper file management.","timestamp":"2025-09-23T14:11:03.103Z","config":{"mode":"explain","level":"beginner","provider":"gemini","model":"gemini-2.5-flash"}}
